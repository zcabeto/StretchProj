doctype html
html
  head
    title= title
    block stylesheets
      link(rel='stylesheet', href='/stylesheets/style.css')
      script(src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js")
  body
    .menu
      h1 #{title} #[button(type="submit" onclick="autoLogin();") See Data]
    nav#side-menu-1
      section#side-content
        .button_bar
          .dropdown 
            .dropdown-header(onclick='toggleDropdown(this)') Choose Attack
            .dropdown-content
              #[button(type="submit" onclick="swapGuide(1, 0);") SQL Injection]
              #[button(type="submit" onclick="swapGuide(2, 0);") Cross-Site Script]
          section#prev-button-atk #[button(type="submit" onclick="swapGuide(-1, -1);") Prev Page]
          section#next-button-atk #[button(type="submit" onclick="swapGuide(-1, 1);") Next Page]
        p#attack-content Choose a potential Attack to get started.
    nav#side-menu-2
      section#side-content
        .button_bar
          .dropdown 
            .dropdown-header(onclick='toggleDropdown(this)') Choose Defense
            .dropdown-content
              #[button(type="submit" onclick="swapGuide(1, 0);") Data Hashing]
              #[button(type="submit" onclick="swapGuide(2, 0);") Input Sanitisation]
              #[button(type="submit" onclick="swapGuide(3, 0);") Input Encoding]
          section#prev-button-def #[button(type="submit" onclick="swapGuide(-1, -1);") Prev Page]
          section#next-button-def #[button(type="submit" onclick="swapGuide(-1, 1);") Next Page]
        p#defence-content Choose a Defensive Method to get started.
    
    section#main-content
      div(style='display: flex; justify-content: space-between; flex-wrap: wrap;')
        div: button#side-menu-toggle-1 Attack
        div(style='text-align: center; width: 100px;')
          label.switch
            if p.charAt(0)=='1'
              input(type="checkbox" checked onclick="flip_Hash();")
            else 
              input(type="checkbox" onclick="flip_Hash();")
            span.slider.round
          div Unhashed Data View
        div(style='text-align: center; width: 100px;')
          label.switch
            if p.charAt(1)=='1'
              input(type="checkbox" checked onclick="flip_SQLI();")
            else 
              input(type="checkbox" onclick="flip_SQLI();")
            span.slider.round
          div SQL Injection
        div(style='text-align: center; width: 100px;')
          label.switch
            if p.charAt(2)=='1'
              input(type="checkbox" checked onclick="flip_XSS();")
            else 
              input(type="checkbox" onclick="flip_XSS();")
            span.slider.round
          div XSS
        div
      button#side-menu-toggle-2 Defense 
      p Please Log In:
      p: #[input(type="text" id="username")] #[input(type="text" id="password")] #[input(type="submit" onclick="tryLogin();")]
      
      if user != null && user != 'null' && user != ''
        if ACCEPT
          if p.charAt(2)=='0' && user
            p SUCCESSFULLY LOGGED IN AS !{user}.
          else 
            p SUCCESSFULLY LOGGED IN AS #{user}.
        else
          if p.charAt(2)=='0' && user
            p ATTEMPTED TO LOG IN AS !{user}. FAILED
          else 
            p ATTEMPTED TO LOG IN AS #{user}. FAILED
    script.
      window.onload = function() {
        help = parseInt(#{h.charAt(0)});
        module = parseInt(#{h.charAt(1)});
        page = parseInt(#{h.charAt(2)});
        if (module == 0) { page = 0; }
        Hash = parseInt(#{p.charAt(0)});
        SQLI = parseInt(#{p.charAt(1)});
        XSS = parseInt(#{p.charAt(2)});
        uCookie = null;
        if (!window.location.href.includes('login?') && !window.location.href.endsWith('login') && !window.location.href.includes('/out')) {
          uCookie = window.location.href.substring(window.location.href.indexOf('login')+6, window.location.href.lastIndexOf('/'));
          window.location.href = '/login'+getQueries();
        }
        refreshProtections();
        document.getElementById("prev-button-atk").style.display = 'none';
        document.getElementById("next-button-atk").style.display = 'none';
        document.getElementById("prev-button-def").style.display = 'none';
        document.getElementById("next-button-def").style.display = 'none';
        if (help) {
          // upon reload the help box stays open by updating it with this element
          document.getElementById('side-menu-1').classList.add('notransition');
          document.getElementById('side-menu-2').classList.add('notransition');
          document.getElementById('main-content').classList.add('notransition');
          see_help(help);
          document.getElementById('side-menu-1').offsetHeight;
          document.getElementById('side-menu-1').classList.remove('notransition');
          document.getElementById('side-menu-2').offsetHeight;
          document.getElementById('side-menu-2').classList.remove('notransition');
          document.getElementById('main-content').offsetHeight;
          document.getElementById('main-content').classList.remove('notransition');

          var openPage = page;
          swapGuide(module, 0);
          swapGuide(-1, openPage);
        }
      };
      function autoLogin() {
        uCookie = null;
        refreshProtections();
        if (SQLI) {
          window.location.href='/data'+getQueries()+'&s=';//&i=&g=';
        } else {
          window.location.href='/data'+getQueries()+'&s=&i=&g=';
        }
      }
      function tryLogin() {
        uCookie = encodeURIComponent(document.getElementById("username").value) || '';
        refreshProtections();
        var password = hash(document.getElementById("password").value) || 'null';
        window.location.href = '/login/'+uCookie+'/'+password+getQueries();
      }
      function hash(plaintext) {
        if (Hash) {
          return CryptoJS.SHA256(plaintext).toString();
        } else {
          return plaintext;
        }
      }

      function flip_help(h) {
        if (help == 0 || help != h){
          help = h;
        } else {
          help = 0;
        }
        refreshProtections();
      }
      function flip_Hash() {
        Hash = 1-Hash;
        refreshProtections();
      }
      function flip_SQLI() {
        SQLI = 1-SQLI;
        refreshProtections();
      }
      function flip_XSS() {
        XSS = 1-XSS;
        refreshProtections();
      }

      function refreshProtections() {
        document.cookie = 'HelpOn=' + help.toString() + module.toString() + page.toString() + '; path=/';
        document.cookie = 'Protections=' + Hash.toString() + SQLI.toString() + XSS.toString() + '; path=/';
        document.cookie = 'User=' + uCookie + '; path=/';
        document.cookie = 'GenreId=0; path=/';
        document.cookie = 'ItemNum=0; path=/';
      }
      function getQueries() {
        return '?p=' + Hash.toString() + SQLI.toString() + XSS.toString() + '&h=' + help.toString() + module.toString() + page.toString();
      }

      function see_help() {
        var menu1 = document.getElementById('side-menu-1');
        var menu2 = document.getElementById('side-menu-2');
        var mainContent = document.getElementById('main-content');
        if (help==0) {
          menu1.style.left = '-300px';
          menu2.style.left = '-300px';
          mainContent.style.marginLeft = '20px';
          document.getElementById('side-menu-toggle-1').style.border = 'none';
          document.getElementById('side-menu-toggle-2').style.border = 'none';
        } else if (help==1) {
          menu1.style.left = '0px';
          menu2.style.left = '-300px';
          mainContent.style.marginLeft = '320px';
          document.getElementById('side-menu-toggle-1').style.border = 'solid';
          document.getElementById('side-menu-toggle-2').style.border = 'none';
        } else if (help==2) {
          menu1.style.left = '-300px';
          menu2.style.left = '0px';
          mainContent.style.marginLeft = '320px';
          document.getElementById('side-menu-toggle-1').style.border = 'none';
          document.getElementById('side-menu-toggle-2').style.border = 'solid';
        }
      }
      document.getElementById('side-menu-toggle-1').addEventListener('click', function() {
        swapGuide(0, 0);
        flip_help(1);
        see_help();
      });
      document.getElementById('side-menu-toggle-2').addEventListener('click', function() {
        swapGuide(0, 0);
        flip_help(2);
        see_help();
      }); 

      function swapGuide(new_module, page_swap) {
        if (new_module != -1) {
          module = new_module;
          page = 0;
        } else {
          page += page_swap;
        }
        if (help == 1) {
          let content = document.getElementById("attack-content");
          //content.innerHTML = module.toString() + page.toString();
          if (module == 0) {
            document.getElementById("prev-button-atk").style.display = 'none';
            document.getElementById("next-button-atk").style.display = 'none';
            content.innerHTML = 'Choose a potential Attack to get started.';
          } else if (module == 1) {
            if (page == 0) {
              document.getElementById("prev-button-atk").style.display = 'none';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = '-->SQL Injection 0<br><br>Most websites deal with a lot of data, all of which requires storage. This is generally done in a database so that a website can retrieve the information we ask for using SQL. For example on the /login page, our entry of a username and password would be filtered into a SQL query that compares them to a database of users to look for a match, similarly on /data, our search text is used as a parameter to inspect a database of movies and look for pattern matches against their title. <br><br>As our input interacts with the backend data so closely, weaponising our entry can allow us to cause some damage - this is part of a technique called SQL Injection. <br><br>The aim of SQL Injection is to, as the name suggests, inject our own SQL code into the websites existing query. For example, for this tutorial lets focus the /login page, where an SQL Query currently compares our username and password input to a list of existing users and aim to add our own code that forces the website to provide us access without entering valid credentials.';
            } else if (page == 1) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = "-->SQL Injection 1<br><br>As SQL Injection can cause such catastrophic damage to a website, any good website has robust protections against it - luckily it’s not too hard to prevent so for this task we will have to turn Input Sanitisation off (see its section in Defence for more). The first step, therefore, is figuring out if SQL Injection possible to begin with. Our input is used in SQL by formatting into a quotation marks in a string in a particular fashion, being something like <br><br>SELECT * FROM table WHERE column1=' *our input* ';<br><br>So in order to figure out if this technique is possible, we need to see how the system reacts to us entering erroneous inputs - if we can cause the website to act in a way that it likely should not then it is likely our input has not been sanitised! The most common technique is entry of a quotation mark, causing there to be three quotation marks in a row that forces an error. Different queries will be written differently so entering any of ' or “ or ` could work, alternatively in case of our inputs being handled with encodings, we might instead try %27 or %22 or %60 respectively. Try some of these out, if any cause error, we know we can use SQL Injection.";
            } else if (page == 2) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = "-->SQL Injection 2<br><br>Now that we know we can use this technique, we need to understand how to safely inject our code, if there is error with the query it will not run. We learnt our input is being entered in quotation marks into the SQL query, so in order to write our own SQL code, we first need to escape the quotation marks. In the username box, therefore, try entering a quotation mark followed by some text - we will see the text become part of the query itself. <br><br>Just as before, we still have the issue of the query’s second quotation mark that will lead to error if we don’t deal with it. For this we can either open a new quote that it will close, or we can comment out the rest of the line - both have their difficulties and uses. To open a new quote we would have to enter something like<br><br>' OR variable='<br><br>As this would add the condition (variable='') to the query, however this can only work if we pick a variable that exists, meaning we have to appropriately guess a name. In this case we have some clue of what the query is dealing with so we might guess the name username, user, password, or pass - try each of these out to see which does not cause error.<br><br>The second method, commenting, also has its ups and downs. For this we do not need to enter anything at all, where starting a comment dismisses the second quotation mark. However, this does truly comment out all of the rest of the query, so commenting could cause error or odd behaviour. Try it out by entering<br><br>' ; # <br><br>where the start of a SQL comment is marked by # which may also have to be entered as %23 if encoded. ";
            } else if (page == 3) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = "-->SQL Injection 3<br><br>Now we have a safe space for us to enter the SQL we would like. For /login to provide us access, we want the SQL Query to return a ‘match’ with the username and password pair we entered, but we can guarantee that the matching condition returns true using our own SQL injected code, utilising the notion that if any clause in a disjunction is true then the whole statement returns true. Therefore we can quite simply try either of the following<br><br>' OR TRUE #<br><br>' OR TRUE OR user=' ";
            } else if (page == 4) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = "-->SQL Injection 4<br><br>Now with a good grasp of SQL Injection, let’s move over to the /data page which shows a table of data. Entering a quotation mark into the search bar reveals once again that our input is filtered directly into a query, but this also tells us that the data in the table is taken from a database. Try entering<br><br>' #<br><br>to give us a sense of the formatting requirements of the query. This should reveal that the query is nested inside brackets that must be closed, so lets instead try<br><br>' ) #<br><br>which should work. Now we know a format that means we can enter our code safely.";
            } else if (page == 5) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = "-->SQL Injection 5<br><br>For this one, as a table is shown, we can see data that is returned from the database and therefore use SQL Injection to change what data we see. A misconfigured website will allow us to instead retrieve data from the table of users instead from the table of movies as it is supposed to be. To do this we need to join the two tables together. Similar to before we can assume the approximate format.<br><br>SELECT * FROM table WHERE column LIKE ' *our input* ';<br><br>So let’s try doing a union with the table of users for which with some trial and error, as we have before, we can learn the table name is Users. Before we try doing this union, we can also limit the data we are doing this union with to try <br><br>' LIMIT 0) UNION ALL (SELECT * FROM Users); #<br><br>If this does not work, continue to the next page.";
            } else if (page == 6) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = "-->SQL Injection 6<br><br>Oh no, it did not work! The movies and users data don’t match appropriately to do this union. Luckily we can get around this without too much difficulty but with a bit of sleuthing. We found earlier that the Users table has two notable columns user and pass, and we can also get the column names of the movie data straight from the table shown. With this in mind we can reformat our input to match the Movies and Users tables together using<br><br>' LIMIT 0) UNION ALL (SELECT user AS title, '' AS Director, pass AS TopTwoActors, '' AS releaseDate, '' AS movieId FROM Users) #<br><br>Try running this with and without the data hashing on - notice that when the hash is off we can see the raw data, something we could use to log in as an authenticated user directly. When the hashing is on, however, the data we receive is not nearly so easily used. The SHA256 hashing process returns an output that cannot be used to retrieve its input so one cannot use this data to directly. So even though SQL Injection retrieved sensitive information, it cannot be immediately used due to the protections put in place.";
            } else if (page == 7) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'none';
              content.innerHTML = '-->SQL Injection 7<br><br>Congratulations! You made it through the SQL Injection tutorial. Did you see how easy it was to gain access to the system, or how simple a command could reveal so much important data? This attacking technique has a well documented ability to enact great power, which is why it is all the more important to protect against it. As commonly as people make this mistake, there is no reason not to put up protections against attackers doing this very thing - especially with such a clear method of defence in Input Sanitisation. Now you know how important it is to stop it.<br><br>Try out any of the previous commands again, but this time with Input Sanitisation on; they don’t work at all as the website safely stays up without revealing sensitive information. If you haven’t already, go check out the respective section in Defences to learn why.';
            }
          } else if (module == 2) {
            if (page == 0) {
              document.getElementById("prev-button-atk").style.display = 'none';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = '-->Cross-Site Scripting (XSS) 0<br><br>Viewable information on a website is usually written in HTML, a markup language that renders data on the front end. It can lay out paragraphs, load photos and organise tables, but something it cannot do is run code. Instead, HTML outsources its code to javascript, being written within script tags that allow it to run. This is what allows more complex behaviour, such as … <br><br>As an attacker, however, we can take advantage of the existence of these isolated script environments and make our own to run some code. The injection of code on to a HTML rendering is called Cross-Site Scripting, or XSS for short. This technique is blocked by a range of means, including blocking potentially malicious inputs with sanitation or by encoding our input so it can be rendered as a simple string. You can read about these in the Input Sanitisation and Input Encoding sections respectively in Defences. For this to work, therefore, both must be disabled.';
            } else if (page == 1) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = '-->Cross-Site Scripting (XSS) 1<br><br>';
            } else if (page == 2) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'block';
              content.innerHTML = '-->Cross-Site Scripting (XSS) 2<br><br>';
            }  else if (page == 3) {
              document.getElementById("prev-button-atk").style.display = 'block';
              document.getElementById("next-button-atk").style.display = 'none';
              content.innerHTML = '-->Cross-Site Scripting (XSS) 3<br><br>';
            } 
          }
        } else if (help == 2) {
          let content = document.getElementById("defence-content");
          if (module == 0) {
            document.getElementById("prev-button-def").style.display = 'none';
            document.getElementById("next-button-def").style.display = 'none';
            content.innerHTML = 'Choose a Defensive Method to get started.';
          } else if (module == 1) {
            if (page == 0) {
              document.getElementById("prev-button-def").style.display = 'none';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Data Hashing 0<br><br>When we set up defences on our website, we do so in order to keep our data safe from reach to view, change or delete, but we can never be comprehensive. We can never reach a point of 100% security and therefore we must ask the question - what if our data is acquired? We need to ensure the data, if reached, is not usable - this generally comes through the last line of defence of encrypting information. <br><br>We saw in the SQL Injection tutorial that it is possible to retrieve the user-base and print it to screen. If this happens we can login with someone else’s data, however when we had Data Hashing turned on we instead retrieved much more obscure information. The user information could not be directly read and used as usernames and passwords could not be discerned. The aim, of course, is for this encrypted data to be as unusable as possible - different methods have varying levels of success…';
            } else if (page == 1) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Data Hashing 1<br><br>';
            } else if (page == 2) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'none';
              content.innerHTML = '-->Data Hashing 2<br><br>';
            }
          } else if (module == 2) {
            if (page == 0) {
              document.getElementById("prev-button-def").style.display = 'none';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Input Sanitisation 0<br><br>Injection techniques can wreak havoc on a system and its data, retrieving things that should not be seen or touched, or assuming capabilities beyond what we designed our website to do. Nevertheless, in many cases there is a simple solution of managing the input more closely and blocking such attempted behaviour. This comes in a few forms. <br><br>First we reduce the amount of ways to enter data to a minimum, replacing potentially vulnerable text inputs with buttons, drop-downs and switches where possible. The step after this is managing the data that is inputted with input sanitisation, where we scrutinise and analyse inputted text to only use it if it is deemed safe.<br><br>The best way for this to work is to have a function or class that handles such things separately, which we can call upon to check a string before using it for a task. This class would be an Input Sanitiser.';
            } else if (page == 1) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Input Sanitisation 1<br><br>';
            } else if (page == 2) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Input Sanitisation 2<br><br>';
            } else if (page == 3) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'none';
              content.innerHTML = '-->Input Sanitisation 3<br><br>';
            }
          } else if (module == 3) {
            if (page == 0) {
              document.getElementById("prev-button-def").style.display = 'none';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Input Encoding 0<br><br>In the Attack: XSS section you may have seen how inputs can act differently when embedded in tags, particularly scripts. This is because of the formatting of HTML that means these tags allow entered text to act in a particular way, rather than exist as simple plaintext. The difference between the two are that specific characters have specific meanings. These different uses can be rendered meaningless if we force the text to be interpreted as a raw string, and the process which can do this is Encoding.<br><br>Character Encoding assigns an input into specific codes that must be individually and independently interpreted as regular characters. Using this means if someone were to input some XSS, it will be read and used as is without running any code. Try inputting that as a search query on /data with Input Encoding on to try this out.';
            } else if (page == 1) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'block';
              content.innerHTML = '-->Input Encoding 1<br><br>';
            } else if (page == 2) {
              document.getElementById("prev-button-def").style.display = 'block';
              document.getElementById("next-button-def").style.display = 'none';
              content.innerHTML = '-->Input Encoding 2<br><br>';
            }
          }
        }
        refreshProtections();
      }
